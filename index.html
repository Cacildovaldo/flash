<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Flash Loan Executor</title>
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      background: #111;
      color: #eee;
      margin: 0;
      padding: 0;
    }
    .container {
      max-width: 1000px;
      margin: 0 auto;
      padding: 30px;
    }
    h1 {
      color: #00c896;
    }
    input, select, button {
      padding: 10px;
      margin: 5px 0;
      border-radius: 5px;
      border: none;
      color: #333; /* Cor do texto para inputs e selects */
    }
    input, select {
      width: 100%;
      background-color: #333; /* Fundo escuro para inputs e selects */
      color: #eee; /* Texto claro */
    }
    button {
      background-color: #00c896;
      color: white;
      cursor: pointer;
    }
    button:hover {
      background-color: #00b386;
    }
    .log {
      background: #000;
      color: #0f0;
      padding: 15px;
      font-family: monospace;
      margin-top: 20px;
      height: 200px;
      overflow-y: scroll;
      border: 1px solid #00c896;
    }
    label {
      margin-top: 10px;
      display: block;
    }
  </style>
</head>
<body>
<div class="container">
  <h1>Flash Loan Arbitragem</h1>
  <button id="connect">Conectar à MetaMask</button>
  <div id="wallet">Carteira: não conectada</div>

  <h2>Parâmetros</h2>
  <label for="contractAddress">Endereço do contrato:</label>
  <input type="text" id="contractAddress" placeholder="0x...">

  <label for="tokenAddress">Endereço do Token Alvo:</label>
  <input type="text" id="tokenAddress" placeholder="0x...">

  <label for="amount">Valor do empréstimo (MATIC):</label>
  <input type="number" id="amount" placeholder="Ex: 5">

  <label for="flashLoanProvider">Provedor de Flash Loan:</label>
  <select id="flashLoanProvider">
    <option value="AAVE">AAVE</option>
    </select>

  <label for="buyDEX">DEX de Compra:</label>
  <select id="buyDEX">
    <option value="QUICKSWAP">QuickSwap</option>
    <option value="UNISWAP">Uniswap V3</option>
  </select>

  <label for="sellDEX">DEX de Venda:</label>
  <select id="sellDEX">
    <option value="QUICKSWAP">QuickSwap</option>
    <option value="UNISWAP">Uniswap V3</option>
  </select>

  <label for="baseSlippage">Slippage Base (em basis points, ex: 100 para 1%):</label>
  <input type="number" id="baseSlippage" value="100" placeholder="Ex: 100">

  <label for="buySlippageMultiplier">Multiplicador de Slippage na Compra (Ex: 2 para 2x o slippage base):</label>
  <input type="number" id="buySlippageMultiplier" value="2" placeholder="Ex: 2">

  <button id="executar">Executar Arbitragem</button>

  <div class="log" id="logs"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
<script>
  // ABI do contrato - Mantenha-a atualizada com seu contrato
  const abi = [
    "function startArbitrage(uint256 amount, address specificToken) external",
    "function addTargetToken(address token) external",
    "function getTargetTokens() view returns (address[])",
    "function setFlashLoanProvider(uint8 _provider) external",
    "function setDEX(uint8 _buyDEX, uint8 _sellDEX) external",
    "function setSlippage(uint256 _baseSlippage, uint256 _buyMultiplier) external", // Adicionado ABI para setSlippage
    "event OperationExecuted(address indexed token, uint256 amount, uint256 profit)"
  ];

  let provider, signer, contract;
  const log = msg => {
    const logs = document.getElementById("logs");
    logs.innerHTML += `[${new Date().toLocaleTimeString()}] ${msg}<br>`;
    logs.scrollTop = logs.scrollHeight;
  };

  document.getElementById("connect").onclick = async () => {
    if (typeof window.ethereum !== 'undefined') {
      try {
        await window.ethereum.request({ method: 'eth_requestAccounts' });
        provider = new ethers.providers.Web3Provider(window.ethereum);
        signer = provider.getSigner();
        const address = await signer.getAddress();
        document.getElementById("wallet").textContent = "Carteira: " + address;
        log("Carteira conectada: " + address);
      } catch (err) {
        log("Erro ao conectar carteira: " + err.message);
      }
    } else {
      alert("MetaMask não encontrada. Instale a extensão no navegador.");
    }
  };

  document.getElementById("executar").onclick = async () => {
    const contractAddr = document.getElementById("contractAddress").value;
    const token = document.getElementById("tokenAddress").value;
    const amount = document.getElementById("amount").value;
    const selectedFlashLoanProvider = document.getElementById("flashLoanProvider").value;
    const selectedBuyDEX = document.getElementById("buyDEX").value;
    const selectedSellDEX = document.getElementById("sellDEX").value;
    const baseSlippage = document.getElementById("baseSlippage").value;
    const buySlippageMultiplier = document.getElementById("buySlippageMultiplier").value;

    if (!contractAddr || !token || !amount || !baseSlippage || !buySlippageMultiplier) {
      return alert("Preencha todos os campos.");
    }
    if (!signer) {
      return alert("Conecte a carteira primeiro.");
    }

    contract = new ethers.Contract(contractAddr, abi, signer);
    const parsedAmount = ethers.utils.parseEther(amount);

    try {
        log("Configurando provedor de Flash Loan, DEXs e Slippage...");
        const flashLoanProviderEnum = selectedFlashLoanProvider === "AAVE" ? 0 : 1; // 0=AAVE, 1=UNISWAP
        const buyDEXEnum = selectedBuyDEX === "QUICKSWAP" ? 0 : 1; // 0=QUICKSWAP, 1=UNISWAP
        const sellDEXEnum = selectedSellDEX === "QUICKSWAP" ? 0 : 1; // 0=QUICKSWAP, 1=UNISWAP

        // Chamar setFlashLoanProvider (se for o owner)
        const txProvider = await contract.setFlashLoanProvider(flashLoanProviderEnum);
        await txProvider.wait();
        log(`Provedor de Flash Loan definido para: ${selectedFlashLoanProvider}`);

        // Chamar setDEX (se for o owner)
        const txDEX = await contract.setDEX(buyDEXEnum, sellDEXEnum);
        await txDEX.wait();
        log(`DEXs de compra/venda definidas para: ${selectedBuyDEX}/${selectedSellDEX}`);

        // Chamar setSlippage (se for o owner)
        const txSlippage = await contract.setSlippage(baseSlippage, buySlippageMultiplier);
        await txSlippage.wait();
        log(`Slippage definido: Base=${baseSlippage}, Multiplicador Compra=${buySlippageMultiplier}`);

        log("Verificando se o token já é alvo...");
        const targetTokens = await contract.getTargetTokens();
        const tokenAlreadyAdded = targetTokens.map(addr => addr.toLowerCase()).includes(token.toLowerCase());

        if (!tokenAlreadyAdded) {
            log("Adicionando token alvo...");
            const tx1 = await contract.addTargetToken(token);
            await tx1.wait();
            log("Token adicionado.");
        } else {
            log("Token já está na lista de alvos. Pulando adição.");
        }
        
        log("Simulando arbitragem para obter a mensagem de erro exata...");
        try {
            await contract.callStatic.startArbitrage(parsedAmount, token);
            log("Simulação bem-sucedida. A transação deve ser executada.");
        } catch (simError) {
            let errorMessage = "Erro desconhecido na simulação.";
            if (simError.data && simError.data.message) {
                errorMessage = simError.data.message; // Mensagem de erro de revert de solidity
            } else if (simError.message) {
                errorMessage = simError.message; // Mensagem genérica da ethers.js
            }
            log(`**SIMULAÇÃO FALHOU: ${errorMessage}**`);
            log("Por favor, verifique os parâmetros, slippage e liquidez. A transação real NÃO será enviada.");
            return; // Impede o envio da transação real se a simulação falhar
        }

        log("Estimando o gás para a transação real...");
        const estimatedGas = await contract.estimateGas.startArbitrage(parsedAmount, token);
        log(`Gás estimado: ${estimatedGas.toString()}`);
        log("Executando arbitragem real...");
        
        // Enviar a transação real com uma margem de gás
        const tx2 = await contract.startArbitrage(parsedAmount, token, {
            gasLimit: estimatedGas.mul(150).div(100) // Aumentando a margem para 50%
        }); 
        
        log("Transação enviada: " + tx2.hash);
        await tx2.wait();
        log("Flash Loan executado com sucesso.");
    } catch (e) {
      log("Erro na operação (MetaMask ou Contrato): " + e.message);
      if (e.code === 'UNPREDICTABLE_GAS_LIMIT' || e.code === -32603) {
          log("Erro de gás imprevisível. Isso geralmente significa que a transação falharia na blockchain.");
          log("Verifique se o valor do empréstimo não excede o limite, se há liquidez suficiente ou se o contrato está configurado corretamente (slippage, minProfit).");
      }
    }
  };
</script>
</body>
</html>
