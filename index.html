<!DOCTYPE html>
<html>
<head>
    <title>Flash Loan Arbitrage - Polygon</title>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.5.2/dist/web3.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --primary: #8247e5;
            --success: #28a745;
            --danger: #dc3545;
            --warning: #ffc107;
            --info: #17a2b8;
        }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; color: #333; }
        .card { background: white; border-radius: 10px; padding: 25px; margin-bottom: 25px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        h1, h2, h3 { color: var(--primary); }
        button { padding: 12px 20px; background: var(--primary); color: white; border: none; border-radius: 6px; cursor: pointer; margin: 8px 5px; font-weight: 600; transition: all 0.3s; }
        button:hover { opacity: 0.9; transform: translateY(-1px); }
        button:disabled { background: #cccccc; transform: none; }
        input, select { padding: 12px; border-radius: 6px; border: 1px solid #ddd; width: 100%; max-width: 400px; margin-bottom: 10px; }
        .status { margin: 20px 0; padding: 15px; border-radius: 6px; }
        .success { background-color: rgba(40, 167, 69, 0.1); color: var(--success); border: 1px solid var(--success); }
        .error { background-color: rgba(220, 53, 69, 0.1); color: var(--danger); border: 1px solid var(--danger); }
        .info { background-color: rgba(23, 162, 184, 0.1); color: var(--info); border: 1px solid var(--info); }
        .flex { display: flex; flex-wrap: wrap; gap: 20px; }
        .stats { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px; margin-top: 20px; }
        .stat-card { background: #f8f9fa; padding: 15px; border-radius: 8px; }
        #priceChart { margin-top: 30px; height: 300px; }
        .token-input { display: flex; align-items: center; gap: 10px; }
        .token-input input { flex: 1; }
        .token-input button { width: 120px; }
        @media (max-width: 768px) {
            .flex { flex-direction: column; }
        }
    </style>
</head>
<body>
    <h1>Flash Loan Arbitrage - Polygon</h1>
    
    <div class="card">
        <h2>Conexão</h2>
        <button id="connectWallet">Conectar Carteira</button>
        <div id="walletStatus" class="status info">Não conectado</div>
    </div>
    
    <div class="card">
        <h2>Configuração do Contrato</h2>
        <div class="flex">
            <div>
                <label for="contractAddress">Endereço do Contrato:</label>
                <div class="token-input">
                    <input type="text" id="contractAddress" placeholder="0x...">
                    <button id="loadContract">Carregar</button>
                </div>
            </div>
            <div>
                <label for="tokenAddress">Token para Arbitragem:</label>
                <input type="text" id="tokenAddress" placeholder="0x...">
            </div>
        </div>
        
        <div class="flex">
            <div>
                <label for="maxLoan">Máximo Empréstimo (MATIC):</label>
                <input type="number" id="maxLoan" placeholder="1000">
            </div>
            <div>
                <label for="minProfit">Lucro Mínimo (MATIC):</label>
                <input type="number" id="minProfit" step="0.01" placeholder="0.1">
            </div>
        </div>
        
        <div class="flex">
            <div>
                <label for="baseSlippage">Slippage Base (%):</label>
                <input type="number" id="baseSlippage" value="0.5" step="0.1" min="0.1" max="5">
            </div>
            <div>
                <label for="buyMultiplier">Multiplicador Compra:</label>
                <input type="number" id="buyMultiplier" value="2" min="1" max="5" step="0.5">
            </div>
        </div>
        
        <button id="saveConfig">Salvar Configuração</button>
        <div id="configStatus" class="status"></div>
    </div>
    
    <div class="card">
        <h2>Operação</h2>
        <div class="flex">
            <div>
                <label for="loanAmount">Valor do Empréstimo (MATIC):</label>
                <input type="number" id="loanAmount" placeholder="500">
            </div>
            <div style="align-self: flex-end;">
                <button id="startArbitrage" disabled>Iniciar Arbitragem</button>
            </div>
        </div>
        
        <div id="operationStatus" class="status info">Aguardando configuração...</div>
        
        <div class="stats">
            <div class="stat-card">
                <h3>Saldo Contrato</h3>
                <p>WMATIC: <span id="wmaticBalance">0</span></p>
                <p>Token: <span id="tokenBalance">0</span></p>
            </div>
            <div class="stat-card">
                <h3>Última Operação</h3>
                <p>Lucro: <span id="lastProfit">0</span> MATIC</p>
                <p>Status: <span id="lastStatus">-</span></p>
            </div>
            <div class="stat-card">
                <h3>Configuração Atual</h3>
                <p>Slippage: <span id="currentSlippage">0.5%</span></p>
                <p>Multiplicador: <span id="currentMultiplier">2x</span></p>
            </div>
        </div>
    </div>
    
    <div class="card">
        <h2>Monitoramento de Preços</h2>
        <canvas id="priceChart"></canvas>
    </div>

    <script>
        // ABI do contrato
        const arbitrageAbi = [ /* Cole aqui o ABI completo do contrato */ ];
        
        // Endereços na Polygon
        const AAVE_POOL = "0x794a61358D6845594F94dc1DB02A252b5b4814aD";
        const QUICKSWAP_ROUTER = "0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff";
        const WMATIC = "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270";
        
        let web3;
        let accounts = [];
        let arbitrageContract;
        let priceChart;
        
        // Elementos da interface
        const connectBtn = document.getElementById('connectWallet');
        const loadContractBtn = document.getElementById('loadContract');
        const saveConfigBtn = document.getElementById('saveConfig');
        const startArbitrageBtn = document.getElementById('startArbitrage');
        const statusDiv = document.getElementById('operationStatus');
        const configStatusDiv = document.getElementById('configStatus');
        
        // Inicialização
        window.addEventListener('load', async () => {
            connectBtn.addEventListener('click', connectWallet);
            loadContractBtn.addEventListener('click', loadContract);
            saveConfigBtn.addEventListener('click', saveConfig);
            startArbitrageBtn.addEventListener('click', startArbitrage);
            
            initPriceChart();
            updateSlippageDisplay();
        });
        
        async function connectWallet() {
            if (window.ethereum) {
                try {
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    web3 = new Web3(window.ethereum);
                    accounts = await web3.eth.getAccounts();
                    
                    updateStatus(`Conectado: ${shortAddress(accounts[0])}`, 'success', statusDiv);
                    connectBtn.textContent = `Conectado: ${shortAddress(accounts[0])}`;
                    
                } catch (error) {
                    updateStatus("Erro ao conectar: " + error.message, 'error', statusDiv);
                }
            } else {
                updateStatus("MetaMask não instalado!", 'error', statusDiv);
            }
        }
        
        async function loadContract() {
            const contractAddress = document.getElementById('contractAddress').value;
            if (!web3.utils.isAddress(contractAddress)) {
                updateStatus("Endereço do contrato inválido", 'error', statusDiv);
                return;
            }
            
            try {
                arbitrageContract = new web3.eth.Contract(arbitrageAbi, contractAddress);
                
                // Verificar ownership
                const owner = await arbitrageContract.methods.owner().call();
                if (owner.toLowerCase() === accounts[0].toLowerCase()) {
                    updateStatus("Contrato carregado com sucesso", 'success', statusDiv);
                    startArbitrageBtn.disabled = false;
                    saveConfigBtn.disabled = false;
                    
                    // Carregar configurações existentes
                    await loadContractSettings();
                    await updateBalances();
                    
                } else {
                    updateStatus("Você não é o dono deste contrato", 'error', statusDiv);
                }
            } catch (error) {
                updateStatus("Erro ao carregar contrato: " + error.message, 'error', statusDiv);
            }
        }
        
        async function loadContractSettings() {
            try {
                const [
                    targetToken,
                    maxLoan,
                    minProfit,
                    baseSlippage,
                    buyMultiplier
                ] = await Promise.all([
                    arbitrageContract.methods.targetToken().call(),
                    arbitrageContract.methods.maxLoanAmount().call(),
                    arbitrageContract.methods.minProfit().call(),
                    arbitrageContract.methods.baseSlippage().call(),
                    arbitrageContract.methods.buySlippageMultiplier().call()
                ]);
                
                document.getElementById('tokenAddress').value = targetToken;
                document.getElementById('maxLoan').value = web3.utils.fromWei(maxLoan, 'ether');
                document.getElementById('minProfit').value = web3.utils.fromWei(minProfit, 'ether');
                document.getElementById('baseSlippage').value = baseSlippage / 100;
                document.getElementById('buyMultiplier').value = buyMultiplier;
                
                updateSlippageDisplay();
                
            } catch (error) {
                console.error("Erro ao carregar configurações:", error);
            }
        }
        
        function updateSlippageDisplay() {
            const base = parseFloat(document.getElementById('baseSlippage').value);
            const multiplier = parseFloat(document.getElementById('buyMultiplier').value);
            
            document.getElementById('currentSlippage').textContent = `${base}%`;
            document.getElementById('currentMultiplier').textContent = `${multiplier}x`;
        }
        
        async function saveConfig() {
            try {
                const tokenAddress = document.getElementById('tokenAddress').value;
                const maxLoan = document.getElementById('maxLoan').value;
                const minProfit = document.getElementById('minProfit').value;
                const baseSlippage = parseFloat(document.getElementById('baseSlippage').value) * 100;
                const buyMultiplier = parseFloat(document.getElementById('buyMultiplier').value);
                
                if (!web3.utils.isAddress(tokenAddress)) {
                    throw new Error("Endereço do token inválido");
                }
                if (maxLoan <= 0 || minProfit <= 0) {
                    throw new Error("Valores devem ser positivos");
                }
                
                updateStatus("Salvando configuração...", 'info', configStatusDiv);
                
                await arbitrageContract.methods.setConfig(
                    tokenAddress,
                    web3.utils.toWei(maxLoan, 'ether'),
                    web3.utils.toWei(minProfit, 'ether')
                ).send({ from: accounts[0] });
                
                await arbitrageContract.methods.setSlippage(
                    Math.round(baseSlippage),
                    Math.round(buyMultiplier)
                ).send({ from: accounts[0] });
                
                updateStatus("Configuração salva com sucesso!", 'success', configStatusDiv);
                await updateBalances();
                updateSlippageDisplay();
                
            } catch (error) {
                updateStatus("Erro ao salvar: " + error.message, 'error', configStatusDiv);
            }
        }
        
        async function startArbitrage() {
            try {
                const amount = document.getElementById('loanAmount').value;
                if (!amount || amount <= 0) {
                    throw new Error("Insira um valor válido");
                }
                
                updateStatus("Iniciando arbitragem...", 'info', statusDiv);
                
                await arbitrageContract.methods.startArbitrage(
                    web3.utils.toWei(amount, 'ether')
                ).send({ from: accounts[0] });
                
                updateStatus("Arbitragem concluída com sucesso!", 'success', statusDiv);
                await updateBalances();
                
                // Atualizar histórico de preços
                updatePriceChart();
                
            } catch (error) {
                updateStatus("Erro na arbitragem: " + error.message, 'error', statusDiv);
            }
        }
        
        async function updateBalances() {
            if (!arbitrageContract) return;
            
            try {
                const contractAddress = arbitrageContract.options.address;
                const tokenAddress = document.getElementById('tokenAddress').value;
                
                const [wmaticBalance, tokenBalance] = await Promise.all([
                    getTokenBalance(WMATIC, contractAddress),
                    tokenAddress && web3.utils.isAddress(tokenAddress) ? 
                        getTokenBalance(tokenAddress, contractAddress) : 
                        Promise.resolve("0")
                ]);
                
                document.getElementById('wmaticBalance').textContent = web3.utils.fromWei(wmaticBalance, 'ether');
                document.getElementById('tokenBalance').textContent = web3.utils.fromWei(tokenBalance, 'ether');
                
            } catch (error) {
                console.error("Erro ao atualizar saldos:", error);
            }
        }
        
        async function getTokenBalance(tokenAddress, holderAddress) {
            return web3.eth.call({
                to: tokenAddress,
                data: web3.eth.abi.encodeFunctionCall({
                    name: 'balanceOf',
                    type: 'function',
                    inputs: [{ type: 'address', name: 'account' }]
                }, [holderAddress])
            });
        }
        
        function initPriceChart() {
            const ctx = document.getElementById('priceChart').getContext('2d');
            priceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: Array(24).fill('').map((_, i) => `${i}h`),
                    datasets: [{
                        label: 'Preço do Token (MATIC)',
                        data: Array(24).fill(0).map((_, i) => (Math.random() * 0.1 + 0.95 - (i / 100))),
                        borderColor: '#8247e5',
                        backgroundColor: 'rgba(130, 71, 229, 0.1)',
                        borderWidth: 2,
                        tension: 0.1,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: false
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return ` ${context.parsed.y.toFixed(4)} MATIC`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function updatePriceChart() {
            // Simulação de atualização de preço após operação
            const data = priceChart.data.datasets[0].data;
            
            // Adiciona flutuação aleatória com um spike positivo
            const lastValue = data[data.length - 1];
            const spike = lastValue * 1.15; // Spike de 15%
            const newValue = lastValue * (0.98 + Math.random() * 0.04); // Volta com variação
            
            // Atualiza dados
            data.shift();
            data.push(spike);
            data.push(newValue);
            
            priceChart.update();
        }
        
        function shortAddress(address) {
            return address ? `${address.substring(0, 6)}...${address.substring(38)}` : '';
        }
        
        function updateStatus(message, type, element) {
            element.textContent = message;
            element.className = `status ${type}`;
        }
    </script>
</body>
</html>
