<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Flash Loan Executor</title>
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      background: #111;
      color: #eee;
      margin: 0;
      padding: 0;
    }
    .container {
      max-width: 1000px;
      margin: 0 auto;
      padding: 30px;
    }
    h1 {
      color: #00c896;
    }
    input, select, button {
      padding: 10px;
      margin: 5px 0;
      border-radius: 5px;
      border: none;
      color: #333; /* Cor do texto para inputs e selects */
    }
    input, select {
      width: 100%;
      background-color: #333; /* Fundo escuro para inputs e selects */
      color: #eee; /* Texto claro */
    }
    button {
      background-color: #00c896;
      color: white;
      cursor: pointer;
    }
    button:hover {
      background-color: #00b386;
    }
    .log {
      background: #000;
      color: #0f0;
      padding: 15px;
      font-family: monospace;
      margin-top: 20px;
      height: 200px;
      overflow-y: scroll;
      border: 1px solid #00c896;
    }
    label {
      margin-top: 10px;
      display: block;
    }
  </style>
</head>
<body>
<div class="container">
  <h1>Flash Loan Arbitragem</h1>
  <button id="connect">Conectar à MetaMask</button>
  <div id="wallet">Carteira: não conectada</div>

  <h2>Parâmetros</h2>
  <label for="contractAddress">Endereço do contrato:</label>
  <input type="text" id="contractAddress" placeholder="0x...">

  <label for="tokenAddress">Endereço do Token Alvo:</label>
  <input type="text" id="tokenAddress" placeholder="0x...">

  <label for="amount">Valor do empréstimo (MATIC):</label>
  <input type="number" id="amount" placeholder="Ex: 5">

  <label for="flashLoanProvider">Provedor de Flash Loan:</label>
  <select id="flashLoanProvider">
    <option value="AAVE">AAVE</option>
    </select>

  <label for="buyDEX">DEX de Compra:</label>
  <select id="buyDEX">
    <option value="QUICKSWAP">QuickSwap</option>
    <option value="UNISWAP">Uniswap V3</option>
  </select>

  <label for="sellDEX">DEX de Venda:</label>
  <select id="sellDEX">
    <option value="QUICKSWAP">QuickSwap</option>
    <option value="UNISWAP">Uniswap V3</option>
  </select>

  <button id="executar">Executar Arbitragem</button>

  <div class="log" id="logs"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
<script>
  // ABI do contrato - Mantenha-a atualizada com seu contrato
  const abi = [
    "function startArbitrage(uint256 amount, address specificToken) external",
    "function addTargetToken(address token) external",
    "function getTargetTokens() view returns (address[])",
    "function setFlashLoanProvider(uint8 _provider) external", // Adicionado para controle via UI
    "function setDEX(uint8 _buyDEX, uint8 _sellDEX) external", // Adicionado para controle via UI
    "event OperationExecuted(address indexed token, uint256 amount, uint256 profit)"
  ];

  let provider, signer, contract;
  const log = msg => {
    const logs = document.getElementById("logs");
    logs.innerHTML += `[${new Date().toLocaleTimeString()}] ${msg}<br>`;
    logs.scrollTop = logs.scrollHeight;
  };

  document.getElementById("connect").onclick = async () => {
    if (typeof window.ethereum !== 'undefined') {
      try {
        await window.ethereum.request({ method: 'eth_requestAccounts' });
        provider = new ethers.providers.Web3Provider(window.ethereum);
        signer = provider.getSigner();
        const address = await signer.getAddress();
        document.getElementById("wallet").textContent = "Carteira: " + address;
        log("Carteira conectada: " + address);
      } catch (err) {
        log("Erro ao conectar carteira: " + err.message);
      }
    } else {
      alert("MetaMask não encontrada. Instale a extensão no navegador.");
    }
  };

  document.getElementById("executar").onclick = async () => {
    const contractAddr = document.getElementById("contractAddress").value;
    const token = document.getElementById("tokenAddress").value;
    const amount = document.getElementById("amount").value;
    const selectedFlashLoanProvider = document.getElementById("flashLoanProvider").value;
    const selectedBuyDEX = document.getElementById("buyDEX").value;
    const selectedSellDEX = document.getElementById("sellDEX").value;

    if (!contractAddr || !token || !amount) {
      return alert("Preencha todos os campos.");
    }
    if (!signer) {
      return alert("Conecte a carteira primeiro.");
    }

    contract = new ethers.Contract(contractAddr, abi, signer);
    const parsedAmount = ethers.utils.parseEther(amount);

    try {
        log("Configurando provedor de Flash Loan e DEXs...");
        // Mapear string para enum (0=QUICKSWAP, 1=UNISWAP para DEX; 0=AAVE, 1=UNISWAP para FlashLoanProvider)
        const flashLoanProviderEnum = selectedFlashLoanProvider === "AAVE" ? 0 : 1;
        const buyDEXEnum = selectedBuyDEX === "QUICKSWAP" ? 0 : 1;
        const sellDEXEnum = selectedSellDEX === "QUICKSWAP" ? 0 : 1;

        // Chamar setFlashLoanProvider e setDEX. Estas chamadas também podem falhar se as permissões estiverem erradas
        // ou se o contrato estiver em um estado inesperado.
        const txProvider = await contract.setFlashLoanProvider(flashLoanProviderEnum);
        await txProvider.wait();
        log(`Provedor de Flash Loan definido para: ${selectedFlashLoanProvider}`);

        const txDEX = await contract.setDEX(buyDEXEnum, sellDEXEnum);
        await txDEX.wait();
        log(`DEXs de compra/venda definidas para: ${selectedBuyDEX}/${selectedSellDEX}`);

        log("Verificando se o token já é alvo...");
        const targetTokens = await contract.getTargetTokens();
        const tokenAlreadyAdded = targetTokens.map(addr => addr.toLowerCase()).includes(token.toLowerCase());

        if (!tokenAlreadyAdded) {
            log("Adicionando token alvo...");
            const tx1 = await contract.addTargetToken(token);
            await tx1.wait();
            log("Token adicionado.");
        } else {
            log("Token já está na lista de alvos. Pulando adição.");
        }
        
        log("Simulando arbitragem para estimar gás e verificar reversões...");
        // Usar callStatic para simular a transação e obter a mensagem de erro em caso de reversão
        try {
            await contract.callStatic.startArbitrage(parsedAmount, token);
            log("Simulação bem-sucedida. A transação deve ser executada.");
        } catch (simError) {
            log(`**SIMULAÇÃO FALHOU: ${simError.message || simError}**`);
            log("A transação será revertida. Por favor, verifique os parâmetros e a liquidez.");
            return; // Impede o envio da transação real se a simulação falhar
        }

        log("Estimando o gás para a transação real...");
        const estimatedGas = await contract.estimateGas.startArbitrage(parsedAmount, token);
        log(`Gás estimado: ${estimatedGas.toString()}`);
        log("Executando arbitragem...");
        
        // Enviar a transação real. Agora a MetaMask terá uma estimativa de gás válida (se a simulação passou).
        const tx2 = await contract.startArbitrage(parsedAmount, token, {
            gasLimit: estimatedGas.mul(120).div(100) // Adiciona uma margem de 20%
        }); 
        
        log("Transação enviada: " + tx2.hash);
        await tx2.wait();
        log("Flash Loan executado com sucesso.");
    } catch (e) {
      log("Erro na operação (MetaMask ou Contrato): " + e.message);
      if (e.code === 'UNPREDICTABLE_GAS_LIMIT' || e.code === -32603) {
          log("Erro de gás imprevisível. Isso geralmente significa que a transação falharia na blockchain.");
          log("Verifique se o valor do empréstimo não excede o limite, se há liquidez suficiente ou se o contrato está configurado corretamente.");
      }
    }
  };
</script>
</body>
</html>
